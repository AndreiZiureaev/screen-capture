<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>JavaScript Screen Recorder</title>
<style>
body {
    font-family: sans-serif;
    text-align: center;
}

#video {
    background-color: black;
    margin-bottom: 1em;
}

#record {
    background-color: rgb(214, 26, 26);
    border: none;
    border-radius: 50%;
    margin-top: 1em;
    height: 5em;
    width: 5em;
}

#record div {
    background-color: white;
    border: none;
    border-radius: 50%;
    margin: auto;
    height: 1.5em;
    width: 1.5em;
}

#download {
    display: none;
    background-color: rgb(75, 218, 57);
    border-radius: 1em;
    color: black;
    text-decoration: none;
    margin-top: 1em;
    padding: 1em;
}
</style>
</head>
<body>
<h1>Screen Recorderino v0.1</h1>
<video id="video" width="569" height="320"></video><br>
<span id="time">0:00</span><br>
<button id="record"><div></div></button><br>
<a id="download">Download</a>
<script>
const video = document.getElementById('video');
const time = document.getElementById('time');
const record = document.getElementById('record');
const recordIcon = record.querySelector('div');
const download = document.getElementById('download');
let url = null;

async function addAudioStream(stream) {
    let audio;
    try {
        audio = await navigator.mediaDevices.getUserMedia({ audio: {
            autoGainControl: false,
            noiseSuppression: false,
            echoCancellation: false,
            channelCount: 1
        }});
    } catch (err) { console.info('No audio: ' + err); return; }

    audio.getAudioTracks().forEach(track => stream.addTrack(track));
}

function startVideo(stream) {
    video.controls = false;
    video.srcObject = new MediaStream(stream.getVideoTracks());
    video.play();
}

function stopVideo() {
    video.pause();
    video.srcObject = null;
    video.src = url;
    video.controls = true;
}

function newRecorder(stream) {
    const recorder = new MediaRecorder(stream, { mimeType: "video/webm" });
    const chunks = [];

    recorder.ondataavailable = e => chunks.push(e.data);
    recorder.onstop = e => finalizeRecording(chunks);

    return recorder;
}

function finalizeRecording(chunks) {
    if (chunks.size == 0) return;

    if (url) URL.revokeObjectURL(url);

    const completeBlob = new Blob(chunks, { type: chunks[0].type });
    url = URL.createObjectURL(completeBlob);

    stopVideo();

    download.href = url;
    download.download = 'capture.webm';
    download.style.display = 'inline-block';
    download.click();
}

function startTimer() {
    const start = Math.floor(performance.now() / 1000);
    let before = start;
    time.innerHTML = '0:00';

    return setInterval(() => {
        const now = Math.floor(performance.now() / 1000);
        if (now == before) return;

        before = now;

        const total = now - start;
        const min = Math.floor(total / 60);
        const sec = total - min * 60;

        time.innerHTML = min + ':' + ((sec < 10) ? '0' + sec : sec);
    }, 200);
}

async function startCapture() {
    let stream;
    try {
        stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
    } catch (err) { console.error('Error: ' + err); return null; }

    await addAudioStream(stream);
    dumpInfo(stream);
    startVideo(stream);

    const recorder = newRecorder(stream);
    recorder.start();

    const iid = startTimer();

    recordIcon.style.borderRadius = 0;

    return { stream, recorder, iid };
}

function stopCapture(bundle) {
    recordIcon.style = '';
    clearInterval(bundle.iid);
    bundle.recorder.stop();
    bundle.stream.getTracks().forEach(track => track.stop());
}

function dumpInfo(stream) {
    stream.getTracks().forEach(track => {
        console.info("\nTrack settings:\n" +
            JSON.stringify(track.getSettings()) +
            "\nTrack constraints:\n" +
            JSON.stringify(track.getConstraints()));
    });
}

function main() {
    let bundle = null;
    let locked = false;

    record.onclick = async e => {
        if (locked) return;
        locked = true;

        if (bundle) {
            stopCapture(bundle);
            bundle = null;
        } else {
            bundle = await startCapture();
        }

        locked = false;
    }
}

main();
</script>
</body>
</html>
